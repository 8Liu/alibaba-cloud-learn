一、volatile关键字
1.保证线程的可见性
2.有序性，禁止指令重排序
volatile语义保证线程可见性有两个原则保证
1)所有volatile修饰的变量一旦被某个线程更改，必须立即刷新到主内存
2)所有volatile修饰的变量在使用之前必须重新读取主内存的值

二、线程通信的三种方式
1.使用等待通知机制控制线程通信（synchronized + wait + notify）
2.使用Condition控制线程通信（Lock + Condition + await + signal）
3.使用阻塞队列控制线程通信（BlockingQueue）
注意：下面三个方法必须在同步方法或同步代码块中调用，而且必须由同步监视器（锁对象）来调用，并且它们的同步监视器（锁对象）必须一致。
wait():让当前线程进入等待阻塞状态，直到其他线程调用此对象的notify()或者notifyAll()方法才唤醒。
         该方法用来将当前线程置入休眠（阻塞）状态，直到接到通知或被中断为止。
         在调用wait（）之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait（）方法。
         进入wait（）方法后，当前线程释放锁。
         在从wait（）返回前，线程与其他线程竞争重新获得锁。如果调用wait（）时，没有持有适当的锁，则抛出IllegalMonitorStateException。
notify()：唤醒在此对象监视器（锁）上等待的单个线程（随机唤醒）
        该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，
        如果调用notify（）时没有持有适当的锁，也会抛出IllegalMonitorStateException。
       该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，
       则线程规划器任意挑选出其中一个wait（）状态的线程来发出通知，并使它等待获取该对象的对象锁，
       但不惊动其他同样在等待被该对象notify的线程们。当第一个获得了该对象锁的wait线程运行完毕以后，
       它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，
       其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，
       直到这个对象发出一个notify或notifyAll。
       这里需要注意：它们等待的是被notify或notifyAll，而不是锁。这与下面的notifyAll（）方法执行后的情况不同。
       特别注意：当在同步中调用wait()方法时，执行该代码的线程会立即放弃它在对象上的锁。
       然而在调用notify()时，并不意味着这时线程会放弃该对象锁，而是要等到程序运行完synchronized代码块后，
       当前线程才会释放锁，wait所在的线程也才可以获取该对象锁。

notifyAll()：唤醒在此对象监视器（锁）上等待的所有线程。
        notifyAll使所有原来在该对象上wait的线程统统退出wait的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，
        在它退出synchronized代码块，释放锁后，其它的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕